Entity::getAtribute(string ett)
        if (att== "id") return id;

enlloc de retornar id millor fer a entity return int, float, string, o el que sigui



EntityMeshh::getAtribute(string ett) {
        Entity::getAtribute();
}

Aixi vaig accedint a tots els metodes de upcasts. Bona idea!

vector <Entity *>* _entityies;


composicio - player -plane

Fer puta classe controller.

Fer vector <Entity*> children


sendEvent ?¿ explicat a la web, 
Basicament es per gestionar accions que poden fer els fills de cada entitat

sendEvent(){
 process event
 
 for childrens
        (it)->sendEvent
        
        
transformacions d'objectes multiples

render{ glpushMatrix matrix.set() render render(child); glPopMatrix(); }
_model -> Posició respecte al seu pare
_worldmodel -> Posició respecte al mon!




Entity* parent;
typedef std::vector<Entity> tEntityList
tentity

setParent(entity*parent)
entity getchild(int)


Cubemap
shaders pel cel. Els pebrots. 
fer mesh per a nuvols i particules
utilitzar create plane de mesh.

plane = new Mesh();
plane = createplane

cloud_text= new texture()
cloud_text-> load(texture)
cloud-> mesh = plane
cloud _> texture = cloud_text;

alpha test a entity
has alpha? 
bool has_alpha;
A RENDER!
if (alpha) {
        glAlphaFunc (gl_gequal
        glenalbe gl_alpha_test
   
 }
        
        glENable(GL_BLEND) Meslca amb radera
        glBlendFunc(GL_SRC_ALPHA , GL_ONE_MINUS_ALPHA)
        
        
        
 tunejar el render per a fer billboards:render 
 
 
 pla orientat a la camara:
 getLocalVector (de camara) 
 camera* camera ) Camera::instance
 vector3  top = camera->getLocalvector(vector3(0,1,0);
 vector3 rigth = camera->getLocalVector(vector3(1,0,0);
 
 vector cantonades del pla a partir de la camara 
 top-right
 -top-rigth
 top*-1 + rigth
 top+rigth
 
 tamany de bilboards. alearoti
 
 gurdar distancies a la camera
 
 for ( entities.size)
 entities[].distance to camara = entitites -> modelg.gettranlation.distace(camara->eye) i aplicar sort
 
 
 
 com ferho sense que els nubols no toquin el depth buffer

 gldepthmask(false)
 plane->render();
 gldepthmask(true) 
 
 
 
 
 bilboard
 std::vector<vecto 3> points;
 plane->verices.reserve(piints.size()*4)
 plane->uvs.reserve(points.size()*4
 for (points.size)
        vertexs aprop uns d'altres
        
        
        
 BulletManager{
 vector<Bullet>
 Max
   render
   update
Pool????

class Bullet{
    public:
        vec3 pos
        vec3 vel
        char typedeffloat TTL
        int author_id
        Bullet() {TTL=0;};
        update(dt);
}


std::Vector<Bullets> bullets;

bullets.resize(MAX_bullet);
for (int i....
        bullet b;
        b.pos.random(100);
        b.TTL= 10; ?????
        bullets.push_back(b);
}

Mesh bullets_mesh;
bullets_mesh.vertices.resize(bullets.size());

update{
        for (size_t i = 0; i< bullets.size; 
        bullet & b = bullets[i]
        bullets_mesh.vertices[i] = b.pos;
        b.TTL -= seconds_elapsed;
        }
        
        
        
 render
        
        if b.TTL <= 0 continue; =?????
        glPointsize();
        glColor3g(1,1,1)
        bullets_mesh.primitive(POINTS)
        bullets_mesh.render(0, true)
        glColor3f(1,1,1)
G = vector3 (0,-1,0)
        for(i->N)
       
       TRAJECTORIES PARABOLIQUES DE LES BALES
      vel = (1, 1, )????
      
      bullets&b = bullets[i];
      b.last_pos= b.pos;  ///Per fer colisions raig esfera (bounds)
      b.pos = b.pos+b.vel*dt;
      b.vel = b.vel+G*dt;
      b.vel = b.vel-b.vel*0.1*dt;
      
      
Colisions:


disparar

if keystate SDL_SCANCODE_SPACE>
bullet b
b.vel = camera->getlocalvector(vecto3(0,0,-19 * 1000);

b.pos = camera->eye;
b.TTL = 10
for (



Mapa Important important important
Perling noise
Grid de triangles //mirar la pagina web tamat. Estas fotut

World-machine 


